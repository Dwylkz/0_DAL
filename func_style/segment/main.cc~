//coder: SXDwylkz
//heads
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <cctype>
#include <algorithm>
#include <vector>
#include <map>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <cmath>
//namespaces
using namespace std;
//constants
const char input[] = "input.in",
	  output[] = "output.out";
const int inf32 = 0x7fffffff,
	  maxn = 1e5 + 10,
	  oo = -1;
const long long inf64 = 0x7fffffffffffffffLL; 

//type definition
typedef unsigned char UC;
typedef unsigned long long ULL;
typedef long long LL;
typedef int int_a[maxn];
typedef bool bool_a[maxn];
typedef char char_a[maxn];
typedef pair<int, int> II;

//simple fuction
LL dMin(LL lv, LL rv) {
	if (rv < lv) {
		swap(rv, lv);
	}
	if (lv == oo) {
		return rv;
	}
	return lv;
}
LL dMax(LL lv, LL rv) {
	if (rv < lv) {
		swap(rv, lv);
	}
	if (lv == oo) {
		return oo;
	}
	return rv;
}

//macro
#define WHERE	puts(__func__);
#define PA(H, A, I, S, E, F,...) {\
	puts(H);\
	for (int I = (S); I < (E); I++) {\
		printf(F,##__VA_ARGS__);\
	}\
	puts("");\
}

struct segment_node {
  segment_node *ls, *rs;
  int l, r;
  void set()
  {
  }
  void push()
  {
  }
  void update()
  {
  }
  int len()
  {
  }
  int mid()
  {
    return l + r >> 1;
  }
  static const int pool_size = 1e6+10;
  static segment_node pool[pool_size], *pool_top;
  static void init()
  {
    pool_top = pool;
  }
  static segment_node *make()
  {
    return pool_top++;
  }
} segment_node::pool[], *segment_node::pool_top;
struct segment {
  segment_node *rt;
  void init(int l, int r)
  {
    build(rt = segment_node::make(), l, r);
  }
  void build(segment_node *x, int l, int r)
  {
    *x = (segment_node){0, 0, l, r};
    if (l < r) {
      int m = l + r >> 1;
      build(x->ls = segment_node::make(), l, m);
      build(x->rs = segment_node::make(), m + 1, r);
    }
  }
  void cover(segment_node *x, int l, int r)
  {
    if (l <= x->l && x->r <= r) {
      x->set();
    } else {
      int m = x->mid();
      x->push();
      if (l <= m) {
        cover(x->ls, l, r);
      }
      if (m < r) {
        cover(x->rs, l, r);
      }
      x->update();
    }
  }
};

//main
int main() {
	return 0;
}
